// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.0--rc1
// source: login/v1/login.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationLoginServiceGetCaptcha = "/login.v1.LoginService/GetCaptcha"
const OperationLoginServiceLogin = "/login.v1.LoginService/Login"
const OperationLoginServiceLoginBySms = "/login.v1.LoginService/LoginBySms"
const OperationLoginServiceLogout = "/login.v1.LoginService/Logout"
const OperationLoginServiceOAuthCallback = "/login.v1.LoginService/OAuthCallback"
const OperationLoginServiceOAuthLogin = "/login.v1.LoginService/OAuthLogin"
const OperationLoginServiceSendSmsCode = "/login.v1.LoginService/SendSmsCode"
const OperationLoginServiceVerifyCaptcha = "/login.v1.LoginService/VerifyCaptcha"

type LoginServiceHTTPServer interface {
	// GetCaptcha 获取图片验证码
	GetCaptcha(context.Context, *GetCaptchaRequest) (*GetCaptchaResponse, error)
	// Login 登陆
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// LoginBySms 手机验证码登录
	LoginBySms(context.Context, *LoginBySmsRequest) (*LoginResponse, error)
	// Logout 登出
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	// OAuthCallback OAuth2.0回调处理
	OAuthCallback(context.Context, *OAuthCallbackRequest) (*OAuthCallbackResponse, error)
	// OAuthLogin OAuth2.0第三方登录
	OAuthLogin(context.Context, *OAuthLoginRequest) (*OAuthLoginResponse, error)
	// SendSmsCode 发送手机验证码
	SendSmsCode(context.Context, *SendSmsCodeRequest) (*SendSmsCodeResponse, error)
	// VerifyCaptcha 验证图片验证码
	VerifyCaptcha(context.Context, *VerifyCaptchaRequest) (*VerifyCaptchaResponse, error)
}

func RegisterLoginServiceHTTPServer(s *http.Server, srv LoginServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/login", _LoginService_Login0_HTTP_Handler(srv))
	r.GET("/v1/logout", _LoginService_Logout0_HTTP_Handler(srv))
	r.GET("/v1/captcha", _LoginService_GetCaptcha0_HTTP_Handler(srv))
	r.POST("/v1/captcha/verify", _LoginService_VerifyCaptcha0_HTTP_Handler(srv))
	r.POST("/v1/sms/code", _LoginService_SendSmsCode0_HTTP_Handler(srv))
	r.POST("/v1/login/sms", _LoginService_LoginBySms0_HTTP_Handler(srv))
	r.POST("/v1/oauth/login", _LoginService_OAuthLogin0_HTTP_Handler(srv))
	r.GET("/v1/oauth/callback/{provider}", _LoginService_OAuthCallback0_HTTP_Handler(srv))
}

func _LoginService_Login0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoginRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceLogin)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Login(ctx, req.(*LoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LoginResponse)
		return ctx.Result(200, reply)
	}
}

func _LoginService_Logout0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LogoutRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceLogout)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Logout(ctx, req.(*LogoutRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LogoutResponse)
		return ctx.Result(200, reply)
	}
}

func _LoginService_GetCaptcha0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetCaptchaRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceGetCaptcha)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetCaptcha(ctx, req.(*GetCaptchaRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetCaptchaResponse)
		return ctx.Result(200, reply)
	}
}

func _LoginService_VerifyCaptcha0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in VerifyCaptchaRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceVerifyCaptcha)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.VerifyCaptcha(ctx, req.(*VerifyCaptchaRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*VerifyCaptchaResponse)
		return ctx.Result(200, reply)
	}
}

func _LoginService_SendSmsCode0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SendSmsCodeRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceSendSmsCode)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SendSmsCode(ctx, req.(*SendSmsCodeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SendSmsCodeResponse)
		return ctx.Result(200, reply)
	}
}

func _LoginService_LoginBySms0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoginBySmsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceLoginBySms)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.LoginBySms(ctx, req.(*LoginBySmsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LoginResponse)
		return ctx.Result(200, reply)
	}
}

func _LoginService_OAuthLogin0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in OAuthLoginRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceOAuthLogin)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OAuthLogin(ctx, req.(*OAuthLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OAuthLoginResponse)
		return ctx.Result(200, reply)
	}
}

func _LoginService_OAuthCallback0_HTTP_Handler(srv LoginServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in OAuthCallbackRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginServiceOAuthCallback)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OAuthCallback(ctx, req.(*OAuthCallbackRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OAuthCallbackResponse)
		return ctx.Result(200, reply)
	}
}

type LoginServiceHTTPClient interface {
	GetCaptcha(ctx context.Context, req *GetCaptchaRequest, opts ...http.CallOption) (rsp *GetCaptchaResponse, err error)
	Login(ctx context.Context, req *LoginRequest, opts ...http.CallOption) (rsp *LoginResponse, err error)
	LoginBySms(ctx context.Context, req *LoginBySmsRequest, opts ...http.CallOption) (rsp *LoginResponse, err error)
	Logout(ctx context.Context, req *LogoutRequest, opts ...http.CallOption) (rsp *LogoutResponse, err error)
	OAuthCallback(ctx context.Context, req *OAuthCallbackRequest, opts ...http.CallOption) (rsp *OAuthCallbackResponse, err error)
	OAuthLogin(ctx context.Context, req *OAuthLoginRequest, opts ...http.CallOption) (rsp *OAuthLoginResponse, err error)
	SendSmsCode(ctx context.Context, req *SendSmsCodeRequest, opts ...http.CallOption) (rsp *SendSmsCodeResponse, err error)
	VerifyCaptcha(ctx context.Context, req *VerifyCaptchaRequest, opts ...http.CallOption) (rsp *VerifyCaptchaResponse, err error)
}

type LoginServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewLoginServiceHTTPClient(client *http.Client) LoginServiceHTTPClient {
	return &LoginServiceHTTPClientImpl{client}
}

func (c *LoginServiceHTTPClientImpl) GetCaptcha(ctx context.Context, in *GetCaptchaRequest, opts ...http.CallOption) (*GetCaptchaResponse, error) {
	var out GetCaptchaResponse
	pattern := "/v1/captcha"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLoginServiceGetCaptcha))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LoginServiceHTTPClientImpl) Login(ctx context.Context, in *LoginRequest, opts ...http.CallOption) (*LoginResponse, error) {
	var out LoginResponse
	pattern := "/v1/login"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLoginServiceLogin))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LoginServiceHTTPClientImpl) LoginBySms(ctx context.Context, in *LoginBySmsRequest, opts ...http.CallOption) (*LoginResponse, error) {
	var out LoginResponse
	pattern := "/v1/login/sms"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLoginServiceLoginBySms))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LoginServiceHTTPClientImpl) Logout(ctx context.Context, in *LogoutRequest, opts ...http.CallOption) (*LogoutResponse, error) {
	var out LogoutResponse
	pattern := "/v1/logout"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLoginServiceLogout))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LoginServiceHTTPClientImpl) OAuthCallback(ctx context.Context, in *OAuthCallbackRequest, opts ...http.CallOption) (*OAuthCallbackResponse, error) {
	var out OAuthCallbackResponse
	pattern := "/v1/oauth/callback/{provider}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLoginServiceOAuthCallback))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LoginServiceHTTPClientImpl) OAuthLogin(ctx context.Context, in *OAuthLoginRequest, opts ...http.CallOption) (*OAuthLoginResponse, error) {
	var out OAuthLoginResponse
	pattern := "/v1/oauth/login"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLoginServiceOAuthLogin))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LoginServiceHTTPClientImpl) SendSmsCode(ctx context.Context, in *SendSmsCodeRequest, opts ...http.CallOption) (*SendSmsCodeResponse, error) {
	var out SendSmsCodeResponse
	pattern := "/v1/sms/code"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLoginServiceSendSmsCode))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LoginServiceHTTPClientImpl) VerifyCaptcha(ctx context.Context, in *VerifyCaptchaRequest, opts ...http.CallOption) (*VerifyCaptchaResponse, error) {
	var out VerifyCaptchaResponse
	pattern := "/v1/captcha/verify"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLoginServiceVerifyCaptcha))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
